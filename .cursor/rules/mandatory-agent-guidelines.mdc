

# Mandatory Agent Guidelines

## Core AI Assistant Guidelines

### 0. Mater rules when using Gemini 2.5 Pro

- Act as an expert coding assistant using Gemini 2.5 Pro. For all tasks, especially Spotify API integration and playlist management: 1. Write concise, modular code optimized for clarity and beginner readability, avoiding unnecessary complexity. 2. Before finalizing code, self-review for syntax, linter, and logical errors, then suggest fixes as comments. 3. Test API requests in small batches to minimize latency; retry failed requests once with a 2-second delay. 4. If errors occur, analyze the error message, identify the root cause, and propose a simplified solution, ensuring Spotify API compatibility. 5. For the ‘shield’ function, prioritize efficient playlist updates with minimal API calls. Document each step in plain English for a non-coder.

### 1. Always Seek Full Context

- Gather entire relevant files and trace every symbol, prop, and function
- Update all references in one pass when making changes

### 2. Respect Linter & Formatting Rules

- Follow project's linter rules and fix errors immediately
- Default to most common conventions in the codebase

### 3. Handle State, Async, and Side Effects Carefully

- Check for state updates, effect dependencies, and async error handling
- Ensure UI, state, and backend stay in sync

### 4. Comprehensive Refactoring

- Search and update ALL usages across the codebase when changing types/props/functions
- Use both semantic and regex search to catch dynamic references

### 5. Clarify Requirements Proactively

- Summarize understanding and confirm if requirements are ambiguous

### 6. Sync Mock and Real Data Paths

- Keep both mock/local and real/API data flows consistent
- Remove mock data when moving to production

### 7. Environment Awareness

- Adapt to user's OS, Node, Expo, and package versions
- Use correct commands for the environment

### 8. Stay Up-to-Date with APIs

- Check latest API/SDK documentation
- Prefer official, stable endpoints

### 9. Test Thoroughly

- Run tests after every change
- Generate comprehensive tests if missing
- Simulate user flows and edge cases

### 10. Iterative, Human-Like Review

- Review work as a human code reviewer
- Look for typos, missed updates, and logic errors

### 11. Proactive Error Handling

- Anticipate runtime errors and handle gracefully
- Add user feedback for all error cases

### 12. Document and Explain

- Add clear comments for complex logic
- Summarize changes and reasoning

### 13. Minimize Disruption

- Avoid breaking changes unless necessary
- Provide migration steps for breaking changes

### 14. Continuous Learning

- Update approach based on mistakes
- Learn from user feedback

### 15. Be Assertive and User-Centric

- Take initiative to fix, test, and verify
- Optimize for best user experience
- Automate repetitive tasks

### 16. Type Safety & Data Validation

- Validate data structures and types
- Use TypeScript consistently
- Handle null/undefined edge cases

### 17. Performance & Optimization Awareness

- Consider performance impact of changes
- Use React.memo, useMemo, useCallback appropriately
- Avoid unnecessary API calls

### 18. Security & Privacy Best Practices

- Never hardcode sensitive data
- Validate and sanitize user inputs
- Follow OAuth 2.0 best practices

### 19. Accessibility & Internationalization

- Include proper accessibility attributes
- Consider screen readers and keyboard navigation
- Plan for internationalization

### 20. Documentation & Code Comments

- Add JSDoc comments for complex functions
- Document API endpoints
- Maintain README files

### 21. Error Boundaries & Graceful Degradation

- Implement React Error Boundaries
- Provide fallback UI
- Handle network issues gracefully

### 22. Version Control & Git Best Practices

- Write clear commit messages
- Consider impact on git history
- Avoid committing temporary files

### 23. Monitoring & Observability

- Add appropriate logging
- Include error tracking
- Monitor API performance

### 24. Terminal Automation & User Experience

- **CRITICAL**: Minimize user interaction requirements in terminal operations
- Use background execution (`is_background: true`) for long-running processes
- Add flags like `--silent`, `--quiet`, `|| true` to prevent hanging
- Redirect stderr (`2>/dev/null`) to avoid noise
- Automate multi-step processes without requiring user confirmation
- Design workflows to be "autopilot" - user should be involved as little as possible
- Use non-interactive commands and avoid prompts that require user input
- Chain commands with `&&` or `;` to execute sequences automatically
- Always provide fallback options and error handling in automated scripts

### 25. State-of-the-Art Industry Standards

- **MANDATORY**: Every UI or code change must follow state-of-the-art, top-tier industry standard practices
- Implement genius-level thinking in all architectural decisions
- Use cutting-edge patterns, libraries, and methodologies
- Follow AAA top-tier app design standards with proper ratios, smooth animations, minimal spacing
- Implement polished, high-end aesthetic with up-to-date best practices
- Use most current and up-to-date best practices for all development
- Research and implement industry-leading solutions before making decisions
- Follow enterprise-grade patterns and security practices
- Implement performance optimizations using latest techniques
- Use modern React/React Native patterns (hooks, context, etc.)
- Follow accessibility standards (WCAG 2.1 AA minimum)
- Implement proper error boundaries and graceful degradation
- Use TypeScript with strict mode and comprehensive typing
- Follow functional programming principles where appropriate
- Implement proper state management patterns (Zustand, Redux Toolkit, etc.)
- Use modern CSS-in-JS or styling solutions
- Implement proper testing strategies (unit, integration, e2e)
- Follow microservices and API design best practices
- Use modern deployment and CI/CD patterns

### 26. BugBot Integration & Automated PR Workflow

- **MANDATORY:** All code changes must follow this workflow to ensure code quality and safety using BugBot.
- **Never commit directly to main.** Always create a feature branch for any change (e.g., `feature/short-description-of-change`).
- After making and testing changes, commit and push the feature branch to GitHub.
- An automated workflow will create a Pull Request (PR) to main.
- **BugBot will automatically review every PR** (if enabled in Cursor dashboard) for security, code quality, and best practices.
- Agents must always remind the user to check BugBot's comments and feedback on the PR before merging.
- **Never merge to main without explicit user permission and after BugBot review.**
- If BugBot finds issues, fix them and update the PR before merging.
- Always provide the user with a direct link to the PR and clear instructions for reviewing BugBot's feedback.
- Use clear, non-technical language when explaining the process to the user.

**Example user message:**
"I've created a Pull Request with your changes. Please check it on GitHub and let me know what BugBot says! The PR is at: [link]. BugBot will review it automatically and add comments if there are any issues."

## Project-Specific Rules

### LLM Selection Guidelines

- Claude 4 Opus: Complex architecture, refactoring, comprehensive tests
- Gemini 2.5 Pro: UI/UX components, debugging, front-end development
- ChatGPT 4.1: Specific feature implementation, API integration

### User Preferences

- Minimize shell hanging with flags like --silent, --quiet, background execution
- Continue background tasks after changes (tests, builds, code quality)
- Only build when explicitly approved
- Start emulator before builds
- Use quick AI agents for routine tasks
- Follow AAA top-tier design standards
- Display app name at top like professional apps
- Execute tasks automatically before asking
- Always run tests to verify correctness
- Remove temporary test scripts
- Use NPM-based environment with 'npx expo install'
- Use custom development client command
- Perform tasks rather than instructing user
- Provide assertive, proactive guidance
- Check actual code thoroughly instead of making assumptions

### Additional Rules (26-31)

- Comprehensive refactoring with usage mapping
- Cross-platform testing
- Dependency awareness
- Rollback planning
- User feedback loops
- CI/CD considerations
- Code review simulation

- CI/CD considerations
- Code review simulation
